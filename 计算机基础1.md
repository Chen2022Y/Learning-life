#### 前言

- #### 进程的由来

  - 进程来源于多道批处理系统，当时的人们为了给多个正在内存中运行的程序起名字，所以有了进程。

- #### 线程的由来

  - 由于进程间的切换开销大，且进程空间无法共享，人们为了解决这些个问题，发明了线程，线程切换开销小，且相同进程的线程可以共享进程空间。

  

### 进程和线程（process，thread）

- 进程是资源分配的基本单位。

- 线程是可执行的基本单位，是可背调度的基本单位。
- 线程不可以自己独立拥有资源，线程的执行必须依赖于所属进程中的资源，进程中必须至少有一个线程。

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgimage-20221111224706819.png" alt="image-20221111224706819" style="zoom: 80%;" />

### 操作系统（OS）

- 狭义：通常指运行在裸设备上，用于抽象并管理硬件资源的软件。

- 广义：能操作的系统，比如K8S，云计算平台等。



### 内核（kernel）

- 内核是操作系统最基本的部分，是基于硬件的第一层软件抽象。
- 内核负责管理操作系统的进程、内存、驱动程序、文件系统、网络系统。



### 宏内核

- 宏内核其实就是把所有的功能都耦合起来，运行在内核进程中，这样的优势是性能极高，因为各个功能模块之间是可以直接调度的。缺点是各个模块相互关联，容易出现一错皆错的问题。Linux就是宏内核



### 微内核

- 与宏内核恰恰相反，它为了降低耦合，内核中只会允许一些核心模块的存在，而其余所有模块都会被移出内核，变成一种特殊的用户进程。其优点是各个模块之间是独立的，不会互相影响，但其性能相比宏内核会低很多。



### 内核态用户态

- 内核管理着操作系统许多重要的软硬件，如果在此基础上，还将大量的软件交于内核管理，那么内核必定不堪重负。
- 处于对内核的性能和安全考虑，将操作系统分为两种模式：用户态、内核态。
- 用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用态运行，内核空间中的代码可以访问所有内存，我们称这些程序在内核态运行。
- 用户态和内核态与CPU的特权有关系，用户态对于CPU的3级特权，内核态对于CPU的0级特权。



### 内核线程和用户线程

> 无论是进程或是线程，Linux 里都统一叫任务，由 task_struct 这个结构体来描述。
>
> 内核线程通常被称为KSE（Kernel Schduling Entity），内核调度实体。这些KSE参与CPU时间片的瓜分。
>
> - 多个KSE在一个CPU核心上运行——并发
> - 多个KSE在多个COU核心上运行——并行

#### **内核线程**

- 内核线程 指需要内核的参与，由内核完成线程的调度，且由内核的内部需求进行创建和撤销。
- 内核线程 的 线程表位于内核中，包括了线程控制块（TCB）。
- 一旦线程阻塞，内核会从当前或者其他进程中重新选择一个新线程保证程序的运行。

#### **用户线程**

- 用户线程 指不需要内核支持而且在用户程序中实现的线程。
- 其不依赖于内核，而是使用线程库提供创建、同步、调度和管理先的函数来控制用户线程。

#### **为什么需要用户线程和内核线程**

- 因为现代软件通常是多个任务同时执行的，所以用户态下的任务变的受欢迎。
- 但是由于用户态需要运行很多任务，Linux2.4版本之前，内核没有提供用户线程的概念。⼈们通常写⼀个线程库来模拟线程。让多个线程在一个进程资源空间中运行，所以说线程是任务（调度单元、代码块） 的最小单位。
- 但是线程库也只是模拟，多个用户线程针对内核还是一个进程，并不能运行到多个CPU核心上。
- 此时CPU的执行还是与进程挂钩，想要实现真正的线程，对内核的改动是非常⼤的。

#### 用户线程于内核线程的实现

​	RedHat 和 IBM 分别给出了方案：

- RedHat 提供了 NPTL(Native POSIX Thread Lsibrary)项⽬
- IBM 提供了 NGTP(Next Generation POSIX Threads)项⽬

​	后来由于各种原因，IBM 放弃了该项⽬。⾄此， RedHat NPTL 项⽬成为 Linux 默认的线程库。各种编程语⾔也提供了很多任务管理的库，Linux 上常⻅的有 C/C++ 线程库 —— Glibc。Glibc 是 GNU 发 布的 C/C++ 运⾏时库，⼏乎任何库都依赖于 Glibc，⽐如 JVM 的线程通过 Native 的⽅式创建任务。⼈们通过 NPTL 调⽤创建线程的函数创造线程，**这些线程是内核级别的线程**。与进程⼀样，内核级别的线程通常也是昂贵的。⾯对**高并发和⼤量的客户端应⽤频繁的创建和销毁内核线程**使得内核不堪重负。**为了尽最⼤⼒度去复⽤内核线程**，**⼈们发明了⽤户线程**。那么，这就产⽣了⼀个问题：**用户线程使用怎样的方式映射到内核线程**？

在现实世界中，⼈们提供了三种⽅式： 

​			• 1:1（内核级线程模型）

​			• 1:N（⽤户级线程模型）

​			• M:N（混合式线程模型）



### 线程模型

- #### 内核级线程模型

​	将**⽤户线程以 1:1 的⽅式映射到内核线程**上。⽤**户线程阻塞之后不会影响其他线程的执⾏**，⽽且可以让多线程程序拥有更好的表现。许多**操作系统限制了内核线程的数量**，所以间接导致⽤户线程受限。⼤部分编程语⾔的线程库如： L i n u x 的 pthread 、 J a v a 的 java.lang.Thread 和 C++ 的 std::thread 都是**包装了操作系统调用的线程**。其**调度完全是操作系统线程调度器来做**。 由于**操作系统内核直接创建线程、销毁线程，并且还需要维护线程的上下⽂信息，因此资源成本⼤幅度上升**。内核级线程模型在多处理器架构上，内核能够并⾏执⾏同⼀个进程中的多个线程，如果发⽣阻塞直接切换同⼀个进程中的其他线程执⾏。该模型的另⼀个缺点在于所有阻塞线程的操作都是以系统调⽤的形式进⾏的。

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgimage-20221112000341111.png" alt="image-20221112000341111" style="zoom: 80%;" />

> 个人理解：
>
> 通过对内核级线程封装的线程库来创建出与不同的KSE静态关联的用户线程，也就是用户线程一对一KSE，两者之间的调度完全由内核的调度器来实现。这种方式实现较为简单，因为约等于是直接使用内核线程实现，而且用户线程之间不会相互影响。但是这种方式对于OS的性能要求较高。







- #### 用户级线程模型

  ​	将⽤**户线程以 N:1 的⽅式映射到内核线程**上。**语⾔运⾏时**通常会**实现⼀个线程调度器**，**线程之间的切换由语⾔运⾏时实现**，内核**感受不到线程的切换和实现**，**内核的所有调度都是基于⽤户进程的**。Python 的 gevent 协程库实现采⽤该模型。该模型对系统资源消耗较⼩，整体上来说较为轻量级。 

  ​	最⼤的缺点在于**不是真正意义上的并发**。某个⽤户线程由于 **I/O 阻塞或者系统调⽤阻塞会导致整个⽤户进程阻塞**，因为⽤户进程中的线程没有接收CPU中断的能⼒， 属于⾃调度。 

  ​	在⽤户级线程模型下，**多处理器架构也只能让一个⽤户进程关联到⼀个CPU核心**，很多协程 库将⼀些阻塞的操作封装成⾮阻塞的，在阻塞代码段让出CPU时间⽚并通过某种⼿段 通知其他⽤户线程运⾏，避免内核调度器由于内核线程阻塞做上下⽂切换，解决整个⽤户进程阻塞问题。

  ​	 该模型**解决了某些操作系统不⽀持线程的情况**，⽤户线程的**状态机切换和上下⽂托管都在⽤户进程中实现**，调度算法**不受操作系统限制**。⽤户级线程模型能够利⽤较多的堆栈空间，并且不需要系统调⽤和系统内核上下⽂切换，更不需要刷新内存⾼速缓存，使得⽤户线程的调⽤速度很快。

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgimage-20221112000556652.png" alt="image-20221112000556652" style="zoom:80%;" />

> 个人理解：
>
> 通过普通线程库来创建用户线程，一个进程内的多个用户线程对应一个KSE，也就是用户线程与KSE是多对一的关系，该模式不是内核支持的线程模式，所以当用户线程系统调用时，对KSE来说是用户进程在系统调用，但因为该模式对线程的创建、销毁、切换都是在用户态完成的，所以对内核态的性能没有影响，也就是说对操作系统的资源消耗很小，这是它的优点。但因其在KSE是进程级的调用，所以一旦发生IO阻塞，那么就相当于该进程里的所有线程都为阻塞状态。
>
> 但是有解决的方法：
>
> 1. 由开发人员开发出一个用户态的调度器，实现对当前线程的判断与调度。
> 2. 调用非阻塞IO，然后在用户态将该KSE控制权交给其他用户线程执行。
> 3. 调用非阻塞IO，然后在用户态保存此时的上下文信息，继续在此KSE执行。
>
> 这几种对开发人员与使用环境有较大考验。







- #### 混合式线程模型

​		将⽤户线程以 N:M 的⽅式映射到内核线程上。 

​		语⾔运⾏时调度器和内核调度器都参与⼯作。

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgimage-20221112000742124.png" alt="image-20221112000742124" style="zoom:80%;" />







### 服务器处理器架构

- ### SMP(对称多处理器架构)

​			在对称多处理架构下，每个处理器的地位都是平等的，通过总线连接到同⼀个共享的物理内存，硬件系统中的所有资源都是共享的，并由单一操作系统来控制。在对称多处理系统上，无论线程是处于用户态，或是内核态，都可以分配到任何一个处理器上运行。因此，线程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。

​			对于 SMP 架构的服务器来说，每⼀个共享环节都并发的访问硬件资源，这就导致当 CPU 数量增加后，资源的抢占不断增加。内存访问冲突将迅速增加，最终会造成CPU资源的浪费，使CPU性能的有效性大大降低。

​			实验证明：SMP 架构的服务器 CPU 利⽤率最好的情况是 2~4 个 CPU

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgSMP_-_Symmetric_Multiprocessor_System.png" style="zoom: 25%;" />







- #### NUMA(非一致存储访问架构)

​			NUMA 的提出在于 SMP 扩展能⼒的限制。不过 NUMA 架构解决横向扩展能⼒的同时带来了访问延迟。NUMA 将资源划 分，提供了 Node（节点）的概念。

​			每个Node都有一套**SMP架构**(不是SMP服务器)，多个Node间通过NUMA的互联模块连接，进行信息交互。所以很显然Node间的通信速度是NUMA的缺点，处理器数量增加的同时无法线性地提升NUMA架构的系统性能。

​			利⽤ NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在⼀个物理服务器内可以⽀持上百个 CPU 。

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgimage-20221110204030731.png" alt="image-20221110204030731" style="zoom: 67%;" />







- #### MMP(大规模并行处理架构)

​			将多个SMP服务器通过网络节点来进行连接，协同工作，完成同一个任务。从用户的角度来看就是一个服务器。

​			MMP的每个节点都只能访问自己本地的资源，无法访问其他节点的资源。所以MMP不存在资源共享的概念。没有资源共享也就不需要异地的访问资源，解决了一部分形态性能的问题。

​			MMP各个节点完成任务后通过网络将各自的处理结果汇总形成最终完成的任务整体。

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgv2-b7a4b2e3376748c30e1e766383e65ec3_720w.webp" alt="img" style="zoom: 50%;" />





> 个人理解：
>
> MPP的优势：
>
> MPP系统不共享资源，因此对它而言，资源比SMP要多，当需要处理的事务达到一定规模时，MPP的效率要比SMP好。由于MPP系统因为要在不同处理单元之间传送信息，在通讯时间少的时候，那MPP系统可以充分发挥资源的优势，达到高效率。也就是说：操作相互之间没有什么关系，处理单元之间需要进行的通信比较少，那采用MPP系统就要好。因此，MPP系统在决策支持和数据挖掘方面显示了优势。
>
> SMP的优势：
>
> MPP系统因为要在不同处理单元之间传送信息，所以它的效率要比SMP要差一点。在通讯时间多的时候，那MPP系统可以充分发挥资源的优势。因此当前使用的OTLP程序中，用户访问一个中心数据库，如果采用SMP系统结构，它的效率要比采用MPP结构要快得多。
>
> NUMA架构的优势：
>
> NUMA架构来看，它可以在一个物理服务器内集成许多CPU，使系统具有较高的事务处理能力，由于远地内存访问时延远长于本地内存访问，因此需要尽量减少不同CPU模块之间的数据交互。显然，NUMA架构更适用于OLTP事务处理环境，当用于数据仓库环境时，由于大量复杂的数据处理必然导致大量的数据交互，将使CPU的利用率大大降低







### 计算机体系分类

- #### SISD（单指令单数据）

  - 规定时间内，一条指令只能处理一个数据

    > 个人认为没什么用

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgsisd.png" alt="img" style="zoom: 50%;" />



- #### SIMD(单指令多数据)

  - 规定时间内，一条指令可以处理多个数据

    > 适合数据量大且操作单一的任务

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgsimd.png" alt="img" style="zoom: 25%;" />



- #### MISD(多指令单数据)

  - 规定时间内，一个数据可以被多个指令处理

    >  适合获得不同的实验数据？

<img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgmisd.png" alt="img" style="zoom:25%;" />



- #### MIMD(多指令多数据)

  - 规定时间内，多个指令处理多个数据

    > 适合数据量大，数据种类不统一的任务

  <img src="https://c-img-v.oss-cn-hangzhou.aliyuncs.com/Learninglife/imgmimd.png" alt="img" style="zoom:25%;" />













### 参考资料

https://zh.m.wikipedia.org/zh-hans/%E8%A1%8C%E7%A8%8B

https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B

https://blog.csdn.net/GaleZhang/article/details/108126740

https://blog.csdn.net/weixin_41247813/article/details/81603445

https://www.cnblogs.com/lfri/p/12597297.html

https://www.cnblogs.com/yeyublog/p/5734374.html

https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8F%B2/7832586

https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F

https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8

https://zhuanlan.zhihu.com/p/394560786

https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B/4703349

https://zh.m.wikipedia.org/zh-my/%E4%BD%BF%E7%94%A8%E8%80%85%E7%A9%BA%E9%96%93

https://cloud.tencent.com/developer/article/1351962

https://juejin.cn/post/6844903960759762958

[ 用户级线程到底有什么用？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/307787570/answer/592442800)

https://juejin.cn/post/6844903962504593421

https://blog.csdn.net/u011043551/article/details/90648895

https://en.wikipedia.org/wiki/Symmetric_multiprocessing

https://en.wikipedia.org/wiki/Non-uniform_memory_access

https://cloud.tencent.com/developer/article/1372348

https://blog.csdn.net/breakout_alex/article/details/110356489

https://learnlearn.uk/alevelcs/sisd-simd-misd-mimd/

https://blog.csdn.net/conowen/article/details/7256260